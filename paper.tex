\documentclass[twocolumn,10pt]{article}

\usepackage[a4paper,hmargin=1.5cm,vmargin=2.5cm,]{geometry}
\setlength{\columnsep}{0.7cm}
%\usepackage{microtype} % nice typesetting  % doesn't work for me :-( -S
\usepackage{amsmath}
\usepackage{graphicx}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\urlstyle{same} % no tt font for URLs
\usepackage{natbib}
\bibliographystyle{genome_research}
%\setcitestyle{aysep={}} 
\usepackage[dvipsnames]{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!50!black}
}
\renewcommand{\dbltopfraction}{0.9}
\renewcommand{\textfraction}{0.15}

\newcommand\blfootnote[1]{%
    \begingroup
    \renewcommand\thefootnote{}\footnote{#1}%
    \addtocounter{footnote}{-1}%
    \endgroup
}

\newcommand{\todo}[1]{[\textcolor{orange}{#1}]}

\begin{document}

\setcounter{secnumdepth}{0}

\twocolumn[{%
\centering
\textbf{\Large Analysing single-cell bisulfite sequencing data with \texttt{scbs}}\\[1.5ex]

Lukas P.~M. Kremer\textsuperscript{1,2,*}, Leonie KÃ¼chenhoff\textsuperscript{1,2}, Santiago Cerrizuela\textsuperscript{2}, \todo{...}, Ana Martin-Villalba\textsuperscript{2}, Simon Anders\textsuperscript{1,*}\\[1ex]
{\footnotesize \textsuperscript{1} BioQuant Centre, University of Heidelberg, Heidelberg, Germany\\[-.5ex]
\textsuperscript{2} Molecular Neurobiology Dept., German Cancer Research Center (DKFZ), Heidelberg, Germany}
\vspace{1.5ex}

June 2022
\vspace{6ex}
}]
\blfootnote{\hspace{-.5cm}\raggedright\textsuperscript{*} e-mail:  \texttt{l.kremer@dkfz-heidelberg.de} and\\ \hspace{1cm}\texttt{simon.anders@bioquant.uni-heidelberg.de}}
\section{Abstract}

[...]

\section{Introduction}

Sequencing-based assays with single-cell resolution have offered new means to understand the differences between the cells making up a sample. Single-cell RNA sequencing (scRNA-seq) techniques have matured at great pace in recent years. Now, methods to study epigenetics at single-cell resolution are rapidly catching up. Of special interest here is DNA methylation, i.e., the methylation of bases in the DNA, which is passed on to daughter cells in cell division. Especially in mammals, such methylation chiefly occurs at cytosine bases that are immediately after followed by guanine bases, so-called CpG \mbox{(5'--C--phosphate--G--3')} sites. 

To detect CpG methylation by sequencing, bisulfite conversion is commonly employed: treatment of DNA with bisulfite causes unmethylated cytosine bases to be deaminated to uracil, which is replaced by thymine in subsequent PCR. Therefore, unmethylated CpGs are read as TG in sequencing of bisulfite-converted DNA while only methylated CpG sites are correctly read as CG \citep{Frommer_1992}. Such so-called bisulfite sequencing has been used for bulk samples since long, and methods for bisulfite sequencing with single-cell resolution were recently developed \citep{Smallwood_2014} and are increasingly used.

CpG dinocleotides are underrepresented in eukaryotic genomes (due to their vulnerability to mutation by conversion to TpG due to spontaneous deamination), and the majority of existing CpG sites are methylated. Presence or absence of the methyl group at CpG sites is believed to affect gene regulation, with methylation inhibiting transcription. The removal of DNA methylation during cell differentiation is therefore conjectured to be an important mechanism to activate genome regions that are required in the target lineage and define cell identity \citep{cedar2022role}. One important application of single-cell bisulfite sequencing (scBS) therefore lies in the study of differentiation processes, for instance in embryonic development \citep{argelaguet2019gastru}.

In the present paper, we discuss strategies to analyze scBS data, suggest improvement to current approaches, show their value in a benchmark, and present software to perform the improved analysis methods.

\subsection{Standard approach}

\begin{figure*}
    \hspace{2.5cm}A\\[-7ex]
    \begin{center}
        \includegraphics[width=0.7\textwidth]{figures/Fig_residuals_A.png}\\
    \end{center}
    \hspace{2.5cm}B\\[-3ex]
    \begin{center}
        \includegraphics[width=0.7\textwidth]{figures/Fig_residuals_B.png}
    \end{center}
    \caption{\small \textbf{Effect of read position:} \textbf{(A)} Depicted is a genomic interval along a chromosome, for which DNA methylation is to be quantified. Two cells cover differing parts of the interval with one read each. If one simply counts for each cell which fraction of the covered CpG sites are methylated, one obtains very different values for the two cells. \textbf{(B)} By averaging each CpG site's methylation over all cells and subsequent smoothing, the thick black ``average methylation curve'' is obtained. To quantify the methylation of cell 1 from (A) relative to this average over all cells, we propose to use the cell's residuals to the smoothed curve (lengths of the vertical red lines) and take their average, counting residuals of methylated CpGs positive and residuals of unmethylated CpGs negative.}
    \label{fig:smoothres}
\end{figure*}


The standard approach to analyse scBS-Seq data is based on methodology developed for the analysis of single-cell RNA-Seq data. Therefore, we will start by briefly reviewing how single-cell \emph{RNA}-Seq data is commonly analysed, before we discuss scBS data analysis.

The starting point in most scRNA-Seq analyses is a matrix of UMI counts (i.e. of counts of distinct RNA molecules), one row for each cell and one column for each gene. A first goal is then to assigning cell types or states to cells, and to this end, one needs to establish which cells are similar to each other, i.e., find a way to quantify the distance (i.e., dissimilarity) between any two given cells' transcriptional profile. A standard approach, used with minor variation in virtually all recent research and automated by popular software such as Seurat \citep{Hao_2021} or ScanPy \citep{Wolf_2018}, is as follows: One first accounts for cell-to-cell variation in sequencing depth by dividing each UMI count by the respective cell's total UMI count, then transforms to a homoskedastic scale by taking the logarithm. In order to avoid matrix elements with zero count to be transformed to minus infinity, one typically adds a very small ``pseudocount'' (often $10^{-4}$) to the normalized fractions before taking the logarithm. Now, one could use Euclidean distances of these vectors of logarithmized fractions as dissimilarity score. However, these scores would be exceedingly noisy due to the strong Poisson noise introduced by the many genes with very low counts. Therefore, one performs a principal component analysis (PCA), keeping only the top few (typically, 20 to 50) components. As Poisson noise is uncorrelated between genes, it will average out in the top principal components, as these are all linear combinations with weight on very many genes. Therefore, Euclidean distances between these ``PCA space'' vectors provide a robust dissimilarity score. Hence, the PCA space representation y are suitable as input to methods like t-SNE and UMAP, which provide a two-dimensional representation of the data, or to methods for clustering (assigning cells to groups by similarity) and trajectory finding (identifying elongated manifolds in PCA space and assigning cells to quasi-1D positions along them).

This procedure is commonly adapted when working with single-cell DNA-methylation data, so that established methods used in scRNA-Seq can be used.
The question is therefore how to construct a suitable matrix as input for the PCA. A simple and common approach, used for instance by \citet{luo2017single}, is to tile the genome into windows of, say, 100~kb size, and calculate for each cell the average methylation of the DNA within each window. To this end, we identify all CpG sites in the window for which we have coverage with at least one read and can hence call the CpG to be either unmethylated or methylated in the cell. Then we denote as average DNA methylation of this window in a given cell the proportion of observed CpG sites in the window that were found to be methylated (Figure \ref{fig:smoothres}A). This yields a matrix, with one row for each cell and one column for each window from the genome tiling, comprising numbers (methylation fractions) between 0 and 1. This matrix is now subjected to PCA.

We think that this analysis strategy has room for improvement, as we will discuss next. Here, we discuss the proposed improvements only qualitatively. For the mathematical details, please see the Methods section. 

\section{Three improvements to processing scBS data}

\subsection{Smoothing residuals} \label{residuals}

We first discuss the task of quantifying the level of methylation in a given, fixed, genomic interval. In Figure \ref{fig:smoothres}A, such an interval is covered by a single read for each of the two cells shown. The read from cell 2 shows much more methylation than the read from cell 1, and a simple analysis would therefore consider that cell as having stronger methylation in the interval. However, given that the two reads agree wherever they overlap, a more parsimonious interpretation would be that the cells do not show difference in methylation within the interval. Rather, both cells, and similarly maybe most other cells, might have stronger methylation in the left third of the interval than in the middle one.

Therefore, we propose to first obtain, for each CpG position, an average methylation across all cells and, then quantify for each individual cell its deviation from this average. In Figure \ref{fig:smoothres}B, the curved line depicts such an average over all cells, the red vertical lines show an individual cell's deviation from the ensemble average. We take the lengths of the red lines as signed values (``residual''), positive for lines extending upwards from the curve (methylated CpG) and negative for lines extending downwards (unmethylated CpG), and take the average over the residual for all the CpGs in the interval that are covered by reads from this cell. The value thus obtained is what we use to quantify this cell's (relative) methylation in the interval. For a genome tiled into such intervals, we thus obtain a matrix, one row per cell, one column per interval, that can be used for downstream analysis, e.g., as input for a PCA.

The signal to noise ratio in a matrix thus obtained will be much better than in a matrix obtained by simply averaging absolute methylation (0 or 1) over all the cell's covered CpG sites in a region. The reason for this is that we reduce the variation in situation as the one depicted in Figure \ref{fig:smoothres}A, where absolute methylation might differ strongly even though there is no actual evidence for a difference between the two cells.

How should one obtain the ensemble average (the curved line in Fig.\ \ref{fig:smoothres}B)? A simple approach to get a value for a specific CpG would be to take all cells with read coverage for the CpG and use the fraction of these that show the CpG as methylated. However, especially when only few cells offer coverage, these averages will be very noisy. Therefore, we propose to smoothen using a kernel smoother, i.e., by performing a kernel-weighted average over the CpG site's neighborhood. The kernel bandwidth (i.e., the size of the neighborhood to average over) is a tuning parameter; we got good results with 1000~bp and used this value for the examples presented here.

\subsection{PCA with imputation}

The standard PCA algorithm cannot deal with missing data. Therefore, one would need to make intervals wide enough to ensure that every interval is covered by at least one read for most windows and discard any interval that is not covered by any single cell. Hence, a naive analysis has to resort to a coarse tiling of the genome. To counter this, we propose a simple and straightforward way to deal with missing data in the input matrix to a PCA: In a first iteration, we replace each missing value in the centered input matrix with zero, then run the PCA. Then, only these zeroes are replaced by the value predicted by the PCA and the PCA is rerun. Convergence is typically achieved after two to five iterations. For details, see Methods. 

The possibility to perform PCA with missing data allows us to use shorter, and thus more intervals and hence provide the PCA with richer input data.

\subsection{Finding variably methylated regions}

\begin{figure}
    \includegraphics[width=\columnwidth]{figures/Fig_sliding.png}
    \caption{\small \textbf{Finding variably methylated regions (VMR):} The chromosomes are divided up into overlapping windows (first five shown at the bottom), and for each window, the cells' methylation values are calculated as described and as depicted in Fig.\ \ref{fig:smoothres}B. Then, the variance of these values is calculated (each point represents one of the overlapping windows), a threshold (dashed line) is chosen such that a chosen quantile of windows have a variance exceeding the threshold. Windows with above-threshold variance are merged if they overlap, yielding the ``variably methylated regions''.}
    \label{vmr}
\end{figure}


Typically, some regions in a chromosome will have very similar methylation status in all cells, while other regions show variability in methylation across cells. For instance, it is long known that CpG-rich promoters of housekeeping genes are unmethylated, and that a large proportion of the remaining genome is highly methylated regardless of cell type \citep{bird1986cpg}. In contrast, DNA methylation at certain genomic features such as enhancers is more dynamic \citep{argelaguet2019gastru}, and thus more variable across cells.
Only the latter regions are of value for our goal of quantitating dissimilarity between cells. We call these the variably methylated regions (VMRs).

So far, we have discussed dividing up (tiling) each chromosome into non-overlapping, equal-sized intervals, and quantitating the methylation of each such window. Such rigid placing of interval boundaries is unlikely to be optimal: for example, a VMR might be much smaller than a tile and its signal will hence be drowned out by the larger part of uninformative CpGs that are equal in all cells, when averaging over all the CpG sites in the tile.

Therefore, we propose the following approach (Fig. \ref{vmr}): Divide up the chromosome into many \emph{overlapping} windows, that start at regular multiples of a fixed, small, step size. Quantify the methylation of each cell in each window by averaging the cell's methylation residuals over all CpGs in the window, as described above and depicted in Figure\ \ref{fig:smoothres}B. Then, calculate for each window the variance of these values over all cells. Select, say, the top 2\% windows with the highest variances and mark them as VMRs. Wherever thus marked windows overlap or are divided by only a small gap, merge them into one larger VMR. Then, calculate for each of these larger VMRs the methylation signal, as before, by averaging for each cell over the residuals of all contained CpG sites.

In this manner, we obtain a methylation matrix, with one row per cell and one column per VMR, that is, in a sense, richer in information and has better signal-to-noise ratio than the matrix obtained by the simple analysis sketched at the very beginning. As we demonstrate below, a PCA performed on such a matrix provided a distance metric for the cells that contains more information on biological detail than one from a simpler analysis. 

Besides providing better input for the distance calculations, the small size of identified VMRs also means that they can be readily compared with genomic annotation, which aids in their functional interpretation.
While a large 100~kb bin will often contain multiple genes with distinct expression patterns, small VMRs located in known regulatory elements or gene bodies are more easily associated with individual genes and their associated function.
Thus, VMRs provide a useful starting point for examining the data with methods from functional genomics.

\section{The \texttt{scbs} Python package}

\begin{figure*}
    \begin{center}
        \includegraphics[width=.8\textwidth]{figures/Fig_workflow.png}
    \end{center}
    \caption{\small \textbf{Overview of the functionalities implemented in the \texttt{scbs} package.}
    \texttt{scbs prepare} parses methylation files produced by common bisulfite sequencing mappers and stores their contents in a compressed format optimised for efficient access to genomic intervals.
    \texttt{scbs} also produces cell-wise summary statistics and quality plots (here: average methylation around the transcription start site) that are used to detect low-quality cells.
    These cells can be discarded with \texttt{scbs filter}.
    To obtain a methylation matrix, similar to the count matrices used in scRNA-seq, the user must first decide in which genomic intervals methylation should be quantified.
    The user may either provide genomic regions of \emph{a priori} interest, or they may choose to discover VMRs (variably-methylated regions) in the data with \texttt{scbs scan}.
    The resulting methylation matrix can then be used for downstream analysis such as cell clustering and dimensionality reduction.
    }
    \label{workflow}
\end{figure*}

We have implemented the approach just described in a Python package with a command line interface, called \texttt{scbs}, which also offers a number of other functionalities for the analysis of scBS data (Figure \ref{workflow}). The starting point of such an analysis are methylation files generated by tools such as Bismark \citep{bismark} or methylpy \citep{methylpy}. For each cell, these tools produce a text file that lists the methylation status of all CpG sites. Since it is inconvenient to work with hundreds or thousands of text files, \texttt{scbs} provides the \texttt{prepare} command which parses these methylation files and stores their content in a compressed format that enables efficient access to all CpG sites of the genome. \texttt{scbs prepare} is flexible and accepts all tabular input formats including Bismark .cov-files, methylpy .allc-files, or even custom user-defined formats.

In brief, we store methylation of each chromosome in a matrix where each column represents a cell and each row represents a base pair. Methylated and unmethylated sites are coded as $+1$ and $-1$, respectively. Since the vast majority of values in this matrix are missing due to the sparsity of scBS data (and because rows for base-pairs not corresponding to a CpG site contain no data), we encode missing values as zero and then store the data in Compressed Sparse Row (CSR) format. This format does not explicitly store zeroes (here: missing values) and is optimized for row-wise access, which results in significant compression and allows fast access to the methylation status of genomic intervals.

\texttt{scbs prepare} also computes a number of summary statistics for each cell, including the mean genome-wide methylation level and the number of observed CpG sites, i.~e. the number of CpG sites that have sequencing coverage. These summary statistics can be used to detect cells with poor quality. The quality of each single cell methylome can furthermore be inspected with \texttt{scbs profile}, which computes the average methylation profile of a set of user-defined genomic regions such as transcription start sites (TSS) at single-cell resolution. The TSS profile is a useful quality control plot since methylation shows a characteristic dip roughly \textpm1~kb around the transcription start site in mammalian genomes. Cells that do not show this pattern, or cells with few observed CpG sites, may then be discarded with \texttt{scbs filter}. 

After quality control, the user has access to the genome-wide VMR detection approach described above via \texttt{scbs scan}. This produces a BED file that lists the genome coordinates of VMRs. To finally obtain a methylation matrix analogous to a scRNA-seq count matrix, this BED file can be used as input for \texttt{scbs matrix}, which quantifies methylation at genomic intervals in all cells. The command produces both the percentage of methylated CpG sites, as well as our proposed methylation measure (shrunken mean of the residuals) that is more robust to variation in sequencing coverage or stochastic differences in read position between cells. We note that both \texttt{matrix} and \texttt{profile} accept any valid BED-file as input, which means that the user can quantify and visualize methylation at any genomic feature of interest, such as promoters, enhancers or transcription factor binding sites, in single cells. The obtained methylation matrix can then serve as input for common single-cell analysis methods such as dimensionality reduction and cell clustering.

\texttt{scbs} is free and open source, and the package can be installed via the Python package manager. The source code and the package are available at \href{https://github.com/LKremer/scbs}{https://github.com/LKremer/scbs}, where we also provide detailed documentation including a tutorial that demonstrates a complete \texttt{scbs} analysis on an example data set.


\section{Benchmarks}
To assess performance of our methods, we obtained two previously published scBS-Seq data sets and re-analysed them with \texttt{scbs}.

\subsection{Correlation with gene expression}

The first data set is a single-cell multi-omics data set generated by \citet{argelaguet2019gastru}. In their work, the authors obtained single-cell methylomes of mouse embryo cells across different stages of development (E4.5--E7.5) as well as single-cell transcriptomes from the same cells. In one of their analyses, the authors calculated the correlation between gene expression and promoter methylation to elucidate the implications of the epigenome on gene expression in development. The authors identified several genes where promoter methylation predicts gene expression, but obtained low correlations for the vast majority of genes. We reasoned that VMRs obtained with the previously described sliding window approach might be a better predictor of gene expression. 

In Figure \ref{figure:correlation}A, we compare correlations of gene expression and promoter methylation to correlations of gene expression and methylation of the closest VMR identified with \texttt{scbs scan}.
This analysis revealed a number of genes whose expression does not correlate with promoter methylation, but correlates with VMR methylation.
This effect is also observed when using our proposed measure of methylation, the shrunken mean of residuals (Figure \ref{figure:correlation}B).

\begin{figure}
    \begin{center}
    A\hspace{.9\columnwidth}~\\
    \includegraphics[width=.7\columnwidth]{part_leonie_git/leonie_plots/corr_methylation_fraction_4kbwindow.pdf} \\
    B\hspace{.9\columnwidth}~\\
    \includegraphics[width=.7\columnwidth]{part_leonie_git/leonie_plots/corr_shrunken_residual_4kbwindow.pdf} \\
    C\hspace{.9\columnwidth}~\\
    \includegraphics[width=.95\columnwidth]{part_leonie_git/leonie_plots/comparison_meth_RNA.pdf}
    \end{center}
    \caption{\small \textbf{Correlation of DNA methylation and gene expression}.
    \textbf{(A)} Correlation of each gene's RNA expression values to the the methylation fractions that were measured at promoters (y-axis), or to methylation fractions of the nearest VMR (x-axis). Promoters are defined as intervals \textpm2~kb around the TSS.
    \textbf{(B)} Same as in (A), but using mean shrunken residuals as a measure of methylation.
    \textbf{(C)} Mean smoothed methylation near the gene Ube2l6 (ENSMUSG00000027078, marked in yellow in A \& B). Cells are assigned to 4 groups based on Ube2l6 expression (group 0: cells with no Ube2l6 expression, groups 1-3: cells that express Ube2l6, divided into three equally large groups with group 3 having the highest expression). The mean methylation level of each group was smoothed with a tricube kernel of bandwidth 2000.
    Data from \citet{argelaguet2019gastru}.}
    \label{figure:correlation}
\end{figure}

To illustrate this effect with an example, we picked a gene where VMR methylation is a much better predictor of gene expression than promoter methylation (Ube2l6, highlighted in orange in Figure \ref{figure:correlation}A,B).
Grouping all cells into four groups according to their level of Ube2l6 expression, it is clearly visible that the promoter of this gene is lowly methylated regardless of gene expression, while methylation at the nearest VMR is greatly decreased in cells with high Ube2l6 expression.

\subsection{Identification of cellular sub-types}

To assess the impact of our methods on dimensionality reduction and the ability to distinguish different (sub)types of cells, we used a data set from \citet{luo2017single}. This data set consists of 3377 single-cell CpG methylomes from the murine frontal cortex, comprising 16 neuronal subtypes.
We subjected this data set to the standard scBS workflow: defining a set of genomic intervals, quantifying methylation in these intervals, and subjecting the resulting matrix to PCA.
We repeated this analysis several times, either using 100~kb tiles or VMRs, and either using methylation fractions or mean shrunken residuals as a measure of methylation. \todo{Is the following correct?} For both types of regions, the 100~kb tiles and the VMRs, we ranked the regions by the number of covering cells (i.e., cells with at least on read in the region) and keep only the top 1000 regions.

To assess performance of each combination of methods, we used a nearest neighbor count score that quantifies how well the different neuronal subtypes are separated in 15 dimensional PC space (see Methods).
The results demonstrate that the 16 neuronal subtypes are more cleanly separated when using our proposed methods (Figure \ref{figure:score}A).
Most of this gain in performance can be attributed to the use of VMRs over genomic tiles. The use of mean shrunken residuals over methylation fractions provides an additional small improvement.

Since some scBS protocols are based on the use of 96-well-plates, and since scBS is costly and labor-intensive, only few laboratories are currently able to obtain thousands of single cell methylomes.
To simulate a smaller data set, we subsampled the frontal cortex data set to 500 cells and repeated our analysis.
Here, our approach keeps its good score, while the simple approach falls behind (Figure \ref{figure:score}B).

Of note, our results show that even few VMRs (here, the 1000 VMRs that have read coverage in the highest number of cells) already contain sufficient information to distinguish neuronal subtypes.
In contrast, the neighbor count score for the top 1000 genomic tiles is much lower.
To visualize the different degrees of separation, we further reduced the PC space from both analyses with UMAP, showing that some neuronal subtypes such as mL5-1 and mDL-3 are separated from the other subtypes when using 1000 VMRs (Figure \ref{figure:score}C).
% why not just plot PC1 vs. PC2 here? % because people will want to see the UMAP. -S
Again, the difference is even more pronounced in the sub-sampled analysis with only 500 cells (Figure \ref{figure:score}D).

\begin{figure*}
    \begin{center}
    A\hspace{.4\textwidth}B\hspace*{.3\textwidth}~\\
    \hspace{.3cm}\includegraphics[width=.35\textwidth]{part_leonie_git/leonie_plots/complete_135k_12cm_log.pdf}
    \hspace{1cm}\includegraphics[width=.35\textwidth]{part_leonie_git/leonie_plots/cell500_20k_12cm_log.pdf}\\
    C\hspace*{.7\textwidth}~\\
    \hspace{.3cm}\includegraphics[width=.75\textwidth]{part_leonie_git/leonie_plots/UMAP_fulldataset.pdf}\\
    D\hspace*{.7\textwidth}~\\
    \hspace{.3cm}\includegraphics[width=.75\textwidth]{part_leonie_git/leonie_plots/UMAP_reduceddataset.pdf}
    \caption{\small \textbf{Benchmark of our methods on single-cell methylomes of 16 neuronal subtypes}. \textbf{(A)} Nearest neighbor count score using four different method combinations and a variable number of genomic intervals (regions) as input to PCA. Exemplary UMAPs for encircled analyses are shown in (C). \textbf{(B)} Same benchmark as in (A), but for a smaller data set consisting of 500 randomly subsampled cells. Exemplary UMAPs for analyses are shown in (D). \textbf{(C)} Two exemplary UMAPs of the full data set and methylation fractions of 100~kb windows (left) or shrunken residuals of variable methylation intervals (right) \textbf{(D)} Two exemplary UMAPs of the smaller data set and methylation fraction of 100 kb windows (left) or shrunken residuals of variable methylation intervals (right). Data from \citet{luo2017single}.}
    \label{figure:score}
    \end{center}
\end{figure*}


\section{Discussion and Conclusion}

%Here we propose a number of new methods for the analysis of single cell methylation data and provide them to the research community as a command line tool called \texttt{scbs}.
%Instead of dividing the genome into coarse-grained tiles, we propose to discover variably-methylated regions (VMRs) in the data itself, which improves performance of common downstream applications.
%We also think that VMRs, due to their smaller size, are easier to interpret than  and furthermore provides a list of candidate regions.
%These regions may then be linked to individual genes, tested for celltype-specific methylation differences, or subjected to gene ontology or motif enrichment, depending on the research question at hand.
%We also propose a number of methods specifically tailored to the sparse nature of scBS data.
%First, we observe 


%- propose a number of new methods for the analysis of scBS data
%- developed methods to analyse scBS data that go beyond simple genome tiling
% - instead we discover potential genomic regions of interest on the data itself, which improves performance of common downstream applications and aids interpretability.
% - VMRs can also be used as input for e.g. motif enrichment, go enrichment etc
%- devised a method to store genome-wide scBS data efficiently
%- propose a new measure of DNA methylation in a genomic interval (~ relative methylation)

%- implement them in Python and release them to the community as a Python package with a CLI
%-> no more custom scripts and manual data wrangling of 1000 text files required, instead every user can quickly go from raw data to count matrix
%- lowers the entry barrier for scBS data analysis and makes this new and exciting data type available to a greater audience

%whats missing?
%- 

\section{Methods}

\subsection{Raw data}

We write $x_{ij}$ for the methylation status of CpG $i$ in cell $j$. The index $i$ runs over all CpG positions present in the genome, the index $j$ over all cells in the assay. We write $x_{ij}=0$ if position $i$ was found to be unmethylated in cell $j$ by bisulfite sequencing , $x_{ij}=1$ if it was methylated, and $x_{ij}=\text{NA}$ if position $i$ was not covered by reads from cell $j$ and the methylation status is therefore not available ("NA"),

These values can be readily obtained from single-cell bisulfite sequencing data using tools like Bismark.

If multiple reads with the same cell barcode cover the positions, these will typically be PCR duplicates of each other and hence agree. Of course, the two alleles of a CpG may differ in their methylation status and while it is in principle possible that one obtains reads stemming the same position on both the paternal and the maternal chromosomes of the same cell, but this is so unlikely that we can ignore the case. Hence, whenever Bismarck reports multiple reads covering the same position in the same cell, we set $x_{ij}$ to 0 or 1 following the majority of reads and put $x_{ij}=\text{NA}$ in case of a tie. 

For later use: We write $C$ for the set of all cells in the assay (i.e., $C$ is the index set for the cell indices $j$). Moreover,
we define $C_i\subset C$ as the set of all those cells $j$ that have reads covering position $i$,
$$ C_i=\{j\in C: x_{ij}\neq\text{NA}\}.$$
Conversely, we define $G_j$ as the set of all the CpG positions $i$ covered by reads from cell $j$ 
$$ G_j=\{i: x_{ij}\neq\text{NA}\}.$$

\subsection{Data storage}

The function \texttt{scbs prepare} reads a set of methylation files (e.g. produced by Bismark) and produces a file that stores the matrix $x$ in a space-efficient format, as follows: $x$ is represented as a SciPy sparse matrix \citep{SciPy}, encoding the actual values 0, 1, and NA as -1, 1, and 0, respectively. Coding NA (the most common value) as 0 leverages SciPy's sparse matrix storage. In all the follows here, any mention of $x$ will, however, always mean the encoding as $x_{ij}\in\{0,1,\text{NA}\}$.

\subsection{Smoothing}

For each CpG position $i$, we write 
$$\overline{x}_i=\langle x_{ij} \rangle_{j\in C_i} = \frac{1}{|C_i|}\sum_{j\in C_i} x_{ij}$$ 
for the average methylation at position $i$, where $\langle\cdot\rangle$ denotes averaging, and the average runs over all the cells $i\in C_j$, i.e. over those cells for which methylation data is available for position $i$.

%\todo{NOTE: Here, we could already do shrinkage and use $\frac{1}{|C_i|+1}\sum_i x_{ij}$ instead. But we don't do that, right?}

We then run a kernel smoother over these per-position averages to obtain the smoothed averages $\tilde x_i$. Specifically, we use
\[ \tilde x_i = \frac{\sum_{i'} \overline x_{i'}\, k_h(d_{ii'})}{\sum_{i'} k_h(d_{ii'})},\]
i.e., $\tilde x_i$ is the weighted average over the per-position averages $\overline{x}_{i'}$, taken over the CpG sites $i'$ in the neighborhood of $i$, and weighted using a smoothing kernel $k_h$ with bandwidth $h$. Here, $d_{ii'}$ is the distance between CpG positions $i$ and $i'$, measured in base pairs, $h$ is the smoothing bandwidth in base pairs (by default, $h=1000$), and $k_h$ is the tricube kernel,

\[ k_h(d) = \left\{
\begin{aligned}
    &\left(1-|d/h|^3\right)^3 &\text{for } |d|<h \\
    &\,0 &\text{otherwise}. 
\end{aligned}
\right.
\]

\subsection{Methylation for an interval}

Next, we discuss averaging methylation over a range of CpG sites.

Given an interval $I$ on the chromosome, we wish to quantify the average methylation $m_{Ij}$ of the CpG sites within the interval for cell $j$. If we interpret $I$ as the set of CpG positions $i$ in the interval, we may write

$$ m_{Ij} = \left< x_{ij} \right>_{i\in I\cap G_j}.$$

Here, the average runs over all those sites $i$ that lie within the interval $I$ and are covered by reads from cell $j$.

If we wish to compare cells, it can be helpful to center this quantity by subtracting its average:

$$ z_{Ij} = m_{Ij} - \langle m_{Ij'}\rangle_{j'\in C}.$$

As an alternative, we suggest to consider the residuals of the individual CpG methylation values $x_{ij}$ from the smoothed average $\tilde x_i$,
$$ r_{ij} = x_{ij} - \tilde x_i, $$
and averaging over these, obtaining
\begin{equation} 
r_{Ij} = \frac{\scriptsize{1}}{\scriptsize{|I\cap C_i|+1}}\sum_{i\in I\cap C_i}\left( x_{ij} - \tilde x_i \right). \label{avgres}
\end{equation}

This is a shrunken average, with denominator $n+1$. This extra pseudocount has the effect of shrinking the value towards the "neutral" value 0, with the shrinkage becoming stronger if the data is "weak" because the number $|I\cap C_i|$ of positions covered by reads from cell $j$  is low. In the extreme case of none of the reads from cell $j$ covering $I$, the sum becomes 0 and the denominator 1, i.e. $r_{Ij}=0$ in this case.

\subsection{Finding variably methylated regions (VMRs)}

For any interval $I$, we denote by $v_I$ the variance of its residual averages $r_{Ij}$:

$$ v_I = \frac{\scriptsize{1}}{\scriptsize{|C_I|}}\left( r_{Ij} - \langle r_{Ij'}\rangle_{j'\in C_I} \right)^2,$$

where the average runs only over the set $C_I=\bigcup_{i\in I}C_i$ of those cells $j$ which have reads covering interval I.

To find VMRs, we define intervals $I_1, I_2, ...$, all of the same width, and with step-wise increasing starts, then calculate $v_1, v_2, ...$ for these intervals. We then mark the intervals with the 2\% highest variances. We take the union of all these intervals, split the union into connected components, and call each component a VMR. Putting that last step in other words: We take all the intervals with variance in the top 2-percentile, fuse intervals that overlap and call the regions thus obtained the VMRs.

\subsection{Calculating cell to cell distances}

Given a set, $\mathcal{V}=\{I^\text{v}_1,I^\text{v}_2,\dots\}$, of intervals corresponding to VMRs, we get a relative methylation fraction $r_{ij}$ for each VMR $I^\text{v}_i$ and each cell $j$ from Eq.\ ()\ref{avgres}). The matrix thus obtained can then be centered and used as input for a PCA. If we calculate the top $R$ principal components, we thus obtain for each cell $j$ an $R$-dimensional principal component vector $\mathbf{x}^\text{P}_j$. For any two cells $j$, $j'$, we use the Euclidean distance $\|\mathbf{x}^\text{P}_j - \mathbf{x}^\text{P}_{j'}\|$ as the measure of dissimilarity of the two cells.
Thus, the matrix of PC scores can be used as input to dimension reduction methods like t-SNE or UMAP, and to clustering methods like the Louvain or Leiden algorithm, which require such a matrix as input to the approximate mnearest neighbor (ANN) finding algorithm that is their first step.

\subsection{PCA with imputation}
[...]

\subsection{Re-analysis of published scBS datasets}
To re-analyze scBS data sets by \citet{luo2017single} and \citet{argelaguet2019gastru}, the genome was first annotated with genomic intervals that were either obtained by tiling the genome into non-overlapping 100~kb bins, or by acquiring VMRs with \texttt{scbs scan} using default options. \todo{Mention choice of top 1000 regions.} For all intervals (VMRs and tiles), the mean methylation fractions and mean shrunken residuals were obtained with \texttt{scbs matrix}. Intervals containing less than four measured CpGs, or that were measured in less than 10\% of cells, were discarded. To select $n$ intervals for further analysis, the top $n$ intervals were picked based on the number of cells that the region was measured in. 
For dimensionality reduction, missing values were imputed with an iterative PCA as described above. To visualize data, UMAP was performed on the final 15 principal components.

\subsection{Nearest neighbor count score}
To assess performance of our methods, we processed mouse CpG methylation data from \citet{luo2017single} with several method combinations and scored each result. The score evaluates the ability of each method combination to separate cell types in 15-dimensional PCA space, based on their CpG methylation. Each score varies between 0 and 1, where higher scores reflect better separation.

\todo{Improve wording} The nearest neighbor count score $nnc(k)$ is based on the $\Gamma$-score \citep{Kireeva_2014}. Each cell $c_j^i$ belongs to a cell type $j$. For each cell, $k$ nearest neighbors $nn_j^k$ were computed based on their Euclidean distance. Based on the cell type $j$ of the $k$ nearest neighbors of each cell, the nnc score $nnc(k)$ was computed with formula (\todo{ref}), in which $d(c_j^i, k_j^i)=1$ if at least 90\% of neighbor classes match the class of cell $c_j^i$ and $d(c_j^i, k_j^i)=0$ if less than 90\% of classes match, while $n$ are the total number of cells.
\begin{equation}
    \text{nnc}(k) = \frac{1}{n}d(c_j^i, k_j^i)
\end{equation}

{\small \bibliography{scbs}}

\end{document}
